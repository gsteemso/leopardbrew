#!/usr/bin/ruby -W0

require 'pathname'
require 'set'

if RUBY_VERSION < '1.8.7'
  abort '$HOMEBREW_RUBY_LIBRARY is unset!' unless ENV['HOMEBREW_RUBY_LIBRARY']
  $:.unshift ENV['HOMEBREW_RUBY_LIBRARY']
  require 'extend/leopard'
  require 'vendor/backports/enumerator'
end

class Cmd
  attr_reader :archflags, :cellar, :config, :optflags, :prefix, :sysroot, :tmpdir

  def initialize(arg0, initial_args)
    @arg0 = arg0
    @given_args = initial_args.freeze
    @config = ENV.fetch('HOMEBREW_CCCFG', '')
    @prefix = ENV['HOMEBREW_PREFIX']
    @cellar = ENV['HOMEBREW_CELLAR']
    @tmpdir = ENV['HOMEBREW_TEMP']
    @sysroot = ENV['HOMEBREW_SDKROOT']
    @archflags = ENV.fetch('HOMEBREW_ARCHFLAGS', '').split(' ')
    @optflags = ENV.fetch('HOMEBREW_OPTFLAGS', '').split(' ')
  end # initialize

  def mode
    @mode ||= if @arg0 == 'cpp' or @arg0 == 'ld'
                @arg0.to_sym
              elsif @given_args.include? '-c'
                @arg0 =~ /(?:c|g|clang)\+\+/ ? :cxx : :cc
              elsif @given_args.include? '-E'
                :ccE
              elsif @arg0 =~ /(?:c|g|clang)\+\+/
                :cxxld
              else
                :ccld
              end
  end # mode

  def tool
    @tool ||= case @arg0
                when 'ld' then 'ld'
                when 'cpp' then 'cpp'
                when /\w\+\+(-\d+(\.\d)?)?$/
                  case ENV['HOMEBREW_CC']
                    when /clang/ then 'clang++'
                    when /llvm-gcc/ then 'llvm-g++-4.2'
                    when /gcc(-\d+(\.\d)?)?$/ then 'g++' + $1.to_s
                  end
                else ENV['HOMEBREW_CC']  # Universal fallback, regardless of invocation name.
              end
  end # tool

  def distill_args
    if ['-v', '-V', '-version', '--version'].any? { |a| a == @given_args[-1] }
      # Don't add linker arguments if -v or similar is passed as sole (or at least last) option.
      # This stops `gcc -v` et sim, with no other meaningful arguments, from outputting a linker
      # error.  Some software misuses `gcc -v` to sniff the GCC version; this covers all bases.
      # This formerly only tested for '-v' and only if it was the only argument, but some software
      # now erroneously prepends things to that, so testing for it as the last argument will have
      # to do.  This actually also covers for a bug in some `configure` scripts, which cause `gcc
      # -V` to wrongly fail by accidentally calling it as `gcc --std=gnu99 -V`.
      return [@given_args[-1]]
    end

    if not(refurbish_args?) or tool == 'ld' or configure?
      distilled_args = @given_args.dup
    else
      distilled_args = refurbished_args
    end

    if sysroot
      if tool == 'ld'
        distilled_args << '-syslibroot' << sysroot
      else
        distilled_args << '-isysroot' << sysroot << "--sysroot=#{sysroot}"
      end
    end

    case mode
      when :ccld  then cflags + distilled_args + cppflags + ldflags
      when :cxxld then cxxflags + distilled_args + cppflags + ldflags
      when :cc    then cflags + distilled_args + cppflags
      when :cxx   then cxxflags + distilled_args + cppflags
      when :ccE   then de_archflag(distilled_args) + cppflags
      when :cpp   then distilled_args + cppflags
      when :ld    then ldflags + distilled_args
    end
  end # distill_args

  def refurbished_args
    @lset = Set.new(library_paths + system_library_paths)
    @iset = Set.new(isystem_paths + include_paths)

    refurbed_args = []
    enum = @given_args.each

    loop do
      case arg = enum.next
        when '-arch'
          if permit_arch_flags?
            refurbed_args << arg << enum.next
          else
            enum.next
          end
        when '-m32', '-m64'
          refurbed_args << arg if permit_arch_flags?
        when /^-Xarch_/
          refurbished = refurbish_arg(enum.next, enum)
          unless refurbished.empty?
            refurbed_args << arg
            refurbed_args += refurbished
          end
        else
          refurbed_args += refurbish_arg(arg, enum)
      end # case arg
    end # loop

    refurbed_args
  end # refurbished_args

  def refurbish_arg(arg, enum)
    refurb_arg_parts = []

    case arg
    when /^-g[1-9]?/, /^-gstabs[1-9+]?/, /^-ggdb[1-9]?/, '-gdwarf-2', /^-march=.+/, /^-mtune=.+/,
      /^-mcpu=.+/, /^-O[0-9zs]?/, '-fast', '-no-cpp-precomp', '-no-install', '-pedantic',
      '-pedantic-errors', '-Wno-long-double', '-Wno-unused-but-set-variable'
      # silently discard
    when '-Wno-unneeded-internal-declaration'
      refurb_arg_parts << arg if tool =~ /clang/
    when '-fopenmp', '-lgomp', '-mno-fused-madd', '-fforce-addr', '-fno-defer-pop',
      '-mno-dynamic-no-pic', '-fearly-inlining', /^-f(?:no-)?inline-functions-called-once/,
      /^-finline-limit/, /^-f(?:no-)?check-new/, '-fno-delete-null-pointer-checks',
      '-fcaller-saves', '-fthread-jumps', '-fno-reorder-blocks', '-fcse-skip-blocks',
      '-frerun-cse-after-loop', '-frerun-loop-opt', '-fcse-follow-jumps', '-fno-regmove',
      '-fno-for-scope', '-fno-tree-pre', '-fno-tree-dominator-opts', '-fuse-linker-plugin'
      # clang doesn't support these flags
      refurb_arg_parts << arg unless tool =~ /^clang/
    when '-Wno-array-bounds', '-Wno-deprecated-register', /^-Wno-error=.+/, '-Wno-format-truncation',
      '-Wno-implicit-fallthrough', '-Wno-invalid-source-encoding', '-Wno-shift-negative-value',
      '-Wno-unused-result', '-Wvla'
      # older gccs don't support these flags
      refurb_arg_parts << arg unless tool =~ /^g..-4.[02]/
    when /^-W[alp],/, /^-Wno-/
      refurb_arg_parts << arg
    when /^-W.*/
      # prune warnings
    when '-macosx_version_min', '-dylib_install_name'
      refurb_arg_parts << "-Wl,#{arg},#{enum.next}"
    when '-multiply_definedsuppress'
      refurb_arg_parts << '-Wl,-multiply_defined,suppress'
    when '-undefineddynamic_lookup'
      refurb_arg_parts << '-Wl,-undefined,dynamic_lookup'
    when /^-isysroot/, /^--sysroot/
      # We set the sysroot
      enum.next
    when '-dylib'
      refurb_arg_parts << "-Wl,#{arg}"
    when /^-I(.+)?/
      # Support both '-Ifoo' (one argument) and '-I foo' (two arguments)
      val  = choke($1) || enum.next
      path = canonical_path(val)
      refurb_arg_parts << "-I#{val}" if keep?(path) and @iset.add?(path)
    when /^-L(.+)?/
      val  = choke($1) || enum.next
      path = canonical_path(val)
      refurb_arg_parts << "-L#{val}" if keep?(path) and @lset.add?(path)
    else
      refurb_arg_parts << arg
    end

    refurb_arg_parts
  end # refurbish_arg

  def de_archflag(these)
    while i = these.index('-arch')
      these.slice!(i, (i + 1) < these.length ? 2 : 1)
    end
    these
  end # de_archflag

  def keep?(path)
    path.start_with?(prefix, cellar, tmpdir) or not path.start_with?('/opt', '/sw', '/usr/X11')
  end

  def cflags
    cflag_args = []

    return cflag_args unless refurbish_args? || configure?

    cflag_args << '-pipe'
    cflag_args << '-w' unless configure? or ENV['HOMEBREW_DISABLE__W']
    cflag_args << "-#{ENV['HOMEBREW_OPTIMIZATION_LEVEL']}" if ENV['HOMEBREW_OPTIMIZATION_LEVEL']
    cflag_args.concat(optflags)
    cflag_args << "-std=#{@arg0}" if @arg0 =~ /c[89]9/
    cflag_args.concat(ENV.fetch('HOMEBREW_FORCE_FLAGS', '').split ' ')
    cflag_args
  end # cflags

  def cxxflags
    cxxflag_args = cflags
    cxxflag_args << '-std=c++11' if cxx11?
    cxxflag_args << '-stdlib=libc++' if libcxx?
    cxxflag_args << '-stdlib=libstdc++' if libstdcxx?
    cxxflag_args
  end # cxxflags

  def cppflags; path_flags('-isystem', isystem_paths) + path_flags('-I', include_paths); end

  def ldflags
    ldflag_args = path_flags('-L', library_paths)
    case mode
      when :ld           then ldflag_args << '-headerpad_max_install_names'
      when :ccld, :cxxld then ldflag_args << '-Wl,-headerpad_max_install_names'
    end
    ldflag_args
  end # ldflags

  def isystem_paths; path_split('HOMEBREW_ISYSTEM_PATHS'); end

  def include_paths; path_split('HOMEBREW_INCLUDE_PATHS'); end

  def library_paths; path_split('HOMEBREW_LIBRARY_PATHS'); end

  def system_library_paths; %W[#{sysroot}/usr/lib /usr/local/lib]; end

  # configure scripts generated with autoconf 2.61 or later export as_nl
  def configure?; ENV.key? 'as_nl'; end

  def refurbish_args?; config.include?('O'); end

  def cxx11?; config.include?('x'); end

  def libcxx?; config.include?('g'); end

  def libstdcxx?; config.include?('h'); end

  def permit_arch_flags?; config.include?('K'); end

  def canonical_path(path)
    path = Pathname.new(path)
    path = path.realpath if path.exist?
    path.to_s
  end

  def path_flags(prefix, paths)
    paths = paths.uniq.select { |path| File.directory?(path) }
    paths.map! { |path| prefix + path }
  end

  def path_split(key); ENV.fetch(key) { '' }.split(File::PATH_SEPARATOR); end

  def choke(val); (val.nil? or (val = val.chomp).empty?) ? nil : val; end
end # Cmd

def log(basename, argv, tool, net_args)
  return unless ENV.key?('HOMEBREW_CC_LOG_PATH')

  adds = net_args - argv
  dels = argv - net_args

  s = ''
  s << "#{basename} called with: #{argv.join(' ')}\n"
  s << "superenv removed:  #{dels.join(' ')}\n" unless dels.empty?
  s << "superenv added:    #{adds.join(' ')}\n" unless adds.empty?
  s << "superenv executed: #{tool} #{net_args.join(' ')}\n\n"
  File.open("#{ENV['HOMEBREW_CC_LOG_PATH']}.cc", 'a+') { |f| f.write(s) }
end # log

if __FILE__ == $PROGRAM_NAME
  ##################################################################### sanity
  abort 'The build tool has reset ENV.  --env=std is required.' unless ENV['HOMEBREW_BREW_FILE']

  if (cc = ENV['HOMEBREW_CC']).nil? || cc.empty? || cc == 'cc'
    # those values are not allowed
    ENV['HOMEBREW_CC'] = 'clang'
  end

  ####################################################################### main

  dirname, basename = File.split($0)

  cmd = Cmd.new(basename, ARGV)
  tool = cmd.tool
  global_args = cmd.distill_args

  log(basename, ARGV, tool, global_args)

  global_args << { :close_others => false } if RUBY_VERSION >= '2.0'
  exec "#{dirname}/xcrun", tool, *global_args
else
  abort "Error:  #{__FILE__} â‰  #{$PROGRAM_NAME}."
end
